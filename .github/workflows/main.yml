name: Deploy to Azure VM

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Update docker-compose.yml with Docker Hub images
      run: |
        # Create a temporary docker-compose file with Docker Hub image references
        sed 's|build:|#build:|g' docker-compose.yml > docker-compose.temp.yml
        sed -i '/dockerfile:/d' docker-compose.temp.yml
        sed -i '/context:/d' docker-compose.temp.yml
        sed -i 's|#build:|build:|g' docker-compose.temp.yml
        
        # Add image references for backend and frontend services
        sed -i '/backend:/a\    image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-backend:latest' docker-compose.temp.yml
        sed -i '/frontend:/a\    image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-frontend:latest' docker-compose.temp.yml
        
        # Replace the original file
        mv docker-compose.temp.yml docker-compose.yml

    - name: Build and push Docker images
      run: |
        # Build all images defined in docker-compose
        docker compose build
        
        # Push all built images to Docker Hub
        docker compose push

    - name: Deploy to Azure VM
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.AZURE_VM_HOST }}
        username: ${{ secrets.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSH_KEY }}
        port: ${{ secrets.AZURE_VM_PORT || 22 }}
        script: |
          # Create application directory
          mkdir -p /home/${{ secrets.AZURE_VM_USERNAME }}/prescription-system
          cd /home/${{ secrets.AZURE_VM_USERNAME }}/prescription-system
          
          # Create docker-compose.yml with Docker Hub images (no build contexts)
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          
          services:
            # PostgreSQL Database
            database:
              image: postgres:15-alpine
              container_name: prescription_db
              environment:
                POSTGRES_DB: prescription_system
                POSTGRES_USER: prescription_user
                POSTGRES_PASSWORD: ${DB_PASSWORD}
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./init-scripts:/docker-entrypoint-initdb.d
              ports:
                - "5432:5432"
              networks:
                - app-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U prescription_user -d prescription_system"]
                interval: 30s
                timeout: 10s
                retries: 3
              restart: unless-stopped
          
            # Spring Boot Backend
            backend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-backend:latest
              container_name: prescription_backend
              environment:
                SPRING_PROFILES_ACTIVE: docker
                SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/prescription_system
                SPRING_DATASOURCE_USERNAME: prescription_user
                SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD}
                SPRING_JPA_HIBERNATE_DDL_AUTO: update
                SPRING_JPA_SHOW_SQL: false
                SERVER_PORT: 8080
              ports:
                - "8080:8080"
              depends_on:
                database:
                  condition: service_healthy
              networks:
                - app-network
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
                interval: 30s
                timeout: 10s
                retries: 3
              restart: unless-stopped
          
            # React Frontend
            frontend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-frontend:latest
              container_name: prescription_frontend
              ports:
                - "3000:80"
              depends_on:
                - backend
              networks:
                - app-network
              restart: unless-stopped
          
          volumes:
            postgres_data:
          
          networks:
            app-network:
              driver: bridge
          EOF
          
          # Create environment file
          cat > .env << 'EOF'
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          EOF
          
          # Load environment variables
          set -a
          source .env
          set +a
          
          # Pull latest images using docker compose
          echo "Pulling latest images..."
          docker compose pull
          
          # Stop existing containers
          echo "Stopping existing containers..."
          docker compose down
          
          # Start new containers
          echo "Starting new containers..."
          docker compose up -d
          
          # Wait for services
          echo "Waiting for services to start..."
          sleep 30
          
          # Check status
          echo "Container status:"
          docker compose ps
          
          # Health checks
          echo "Running health checks..."
          
          # Check backend health
          if curl -f -s http://localhost:8080/actuator/health > /dev/null 2>&1; then
            echo "âœ… Backend is healthy"
          else
            echo "âŒ Backend health check failed"
            docker compose logs backend
          fi
          
          # Check frontend
          if curl -f -s http://localhost:3000/ > /dev/null 2>&1; then
            echo "âœ… Frontend is healthy"
          else
            echo "âŒ Frontend health check failed"  
            docker compose logs frontend
          fi
          
          # Check database
          if docker compose exec -T database pg_isready -U prescription_user -d prescription_system > /dev/null 2>&1; then
            echo "âœ… Database is healthy"
          else
            echo "âŒ Database health check failed"
            docker compose logs database
          fi
          
          # Clean up unused images
          echo "Cleaning up unused images..."
          docker image prune -f
          
          echo "ğŸš€ Deployment completed!"
          echo "Frontend: http://$(curl -s ifconfig.me):3000"
          echo "Backend: http://$(curl -s ifconfig.me):8080"

  notify:
    needs: build-and-deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify deployment result
      run: |
        if [[ "${{ needs.build-and-deploy.result }}" == "success" ]]; then
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ”— Your application is now live!"
        else
          echo "âŒ Deployment failed!"
          echo "Please check the logs above for details."
          exit 1
        fi