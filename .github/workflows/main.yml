name: Deploy to Azure VM

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    # 1. Get the code
    - name: Checkout code
      uses: actions/checkout@v4

    # 2. Set up Java 17
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Create application-test.properties
      run: |
        cd Backend
        mkdir -p src/main/resources
        cat > src/main/resources/application-test.properties << EOF
        spring.application.name=medscribe-backend-test
        spring.datasource.url=jdbc:h2:mem:testdb
        spring.datasource.driver-class-name=org.h2.Driver
        spring.datasource.username=sa
        spring.datasource.password=password
        spring.jpa.hibernate.ddl-auto=create-drop
        spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
        spring.jpa.show-sql=false
        app.jwt.secret=test-secret-key-for-jwt-token-generation-in-test-environment
        app.jwt.expiration=86400000
        server.port=8080
        server.servlet.context-path=/api
        logging.level.root=WARN
        logging.level.com.medscribe=INFO
        EOF

    - name: Add H2 dependency for tests
      run: |
        cd Backend
        # Add H2 dependency to pom.xml for testing
        sed -i '/<\/dependencies>/i\
        \t\t<!-- H2 Database for Testing -->\
        \t\t<dependency>\
        \t\t\t<groupId>com.h2database</groupId>\
        \t\t\t<artifactId>h2</artifactId>\
        \t\t\t<scope>test</scope>\
        \t\t</dependency>' pom.xml

    - name: Run tests
      run: |
        cd Backend
        mvn clean test -Dspring.profiles.active=test
      env:
        SPRING_PROFILES_ACTIVE: test

    # 3. Build backend JAR
    - name: Build backend JAR
      run: |
        cd Backend
        chmod +x mvnw
        ./mvnw clean package -DskipTests
        ls -la target/

    # 4. Login to Docker Hub
    - name: Login to Docker Hub
      run: |
        echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

    # 5. Build and push backend
    - name: Build and push backend
      run: |
        docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/prescription-backend:latest ./Backend
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/prescription-backend:latest

    # 6. Build and push frontend  
    - name: Build and push frontend
      run: |
        docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/prescription-frontend:latest ./Frontend
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/prescription-frontend:latest

    # 7. Deploy to VM
    - name: Deploy to VM
      run: |
        # Create SSH key
        echo "${{ secrets.AZURE_VM_SSH_KEY }}" > key.pem
        chmod 600 key.pem
        
        # Create docker-compose content
        cat > docker-compose.yml << 'COMPOSE_EOF'
        version: '3.8'
        services:
          database:
            image: postgres:15-alpine
            container_name: prescription_db
            environment:
              POSTGRES_DB: prescription_system
              POSTGRES_USER: prescription_user
              POSTGRES_PASSWORD: prescription_password
            volumes:
              - postgres_data:/var/lib/postgresql/data
            ports:
              - "5432:5432"
            networks:
              - app-network
            restart: unless-stopped

          backend:
            image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-backend:latest
            container_name: prescription_backend
            environment:
              SPRING_PROFILES_ACTIVE: docker
              SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/prescription_system
              SPRING_DATASOURCE_USERNAME: prescription_user
              SPRING_DATASOURCE_PASSWORD: prescription_password
              SPRING_JPA_HIBERNATE_DDL_AUTO: update
              SPRING_JPA_SHOW_SQL: false
              SERVER_PORT: 8080
            ports:
              - "8080:8080"
            depends_on:
              - database
            networks:
              - app-network
            restart: unless-stopped

          frontend:
            image: ${{ secrets.DOCKERHUB_USERNAME }}/prescription-frontend:latest
            container_name: prescription_frontend
            ports:
              - "3000:80"
            depends_on:
              - backend
            networks:
              - app-network
            restart: unless-stopped

        volumes:
          postgres_data:

        networks:
          app-network:
            driver: bridge
        COMPOSE_EOF
        
        # SSH and deploy
        ssh -i key.pem -o StrictHostKeyChecking=no ${{ secrets.AZURE_VM_USERNAME }}@${{ secrets.AZURE_VM_HOST }} << 'SSH_EOF'
          # Create app directory
          mkdir -p ~/prescription-app
          cd ~/prescription-app
          
          # Login to Docker Hub on remote server
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
        SSH_EOF
        
        # Copy docker-compose file to remote server
        scp -i key.pem -o StrictHostKeyChecking=no docker-compose.yml ${{ secrets.AZURE_VM_USERNAME }}@${{ secrets.AZURE_VM_HOST }}:~/prescription-app/
        
        # Deploy on remote server
        ssh -i key.pem -o StrictHostKeyChecking=no ${{ secrets.AZURE_VM_USERNAME }}@${{ secrets.AZURE_VM_HOST }} << 'DEPLOY_EOF'
          cd ~/prescription-app
          
          # Pull latest images and restart
          docker-compose pull
          docker-compose down
          docker-compose up -d
          
          # Quick status check
          sleep 15
          docker-compose ps
          
          echo "ðŸš€ Deployment completed!"
          echo "Frontend: http://${{ secrets.AZURE_VM_HOST }}:3000"
          echo "Backend: http://${{ secrets.AZURE_VM_HOST }}:8080"
        DEPLOY_EOF
        
        # Clean up
        rm -f key.pem docker-compose.yml